/*
Program Title: Game.cpp
Author: Darren Glyn Roberts
Date: 07/03/2013
Version: 1.0
*/

#include <gl/gl.h>    // Header File For The OpenGL32 Library
#include <gl/glu.h>   // Header File For The GLu32 Library
#include <gl/glaux.h> // Header File For The Glaux Library
#include <sstream>    // String stream
#include <fstream>    // File stream
#include "Game.h"     // Header file for Game class
#define GL_CLAMP_TO_EDGE 0x812F // Clamp textures to edge, used when texture mapping

using namespace std; // Standard namespace
    
void box(GLuint texture) // Draw a textured cube
{
    glColor3f(1, 1, 1); // White background just in case
    glDisable(GL_COLOR_MATERIAL); 
    glBindTexture(GL_TEXTURE_2D, texture); // Texture
    
    glBegin(GL_QUADS); // Cube with same texture each side
    
        glTexCoord2f(0.0f, 1.0f); glVertex3f(0, 0, 1);
        glTexCoord2f(1.0f, 1.0f); glVertex3f(1, 0, 1);
        glTexCoord2f(1.0f, 0.0f); glVertex3f(1, -1, 1);
        glTexCoord2f(0.0f, 0.0f); glVertex3f(0, -1, 1);
     
        glTexCoord2f(0.0f, 1.0f); glVertex3f(0, 0, 1); 
        glTexCoord2f(1.0f, 1.0f); glVertex3f(0, -1, 1);  
        glTexCoord2f(1.0f, 0.0f); glVertex3f(0, -1, 0);
        glTexCoord2f(0.0f, 0.0f); glVertex3f(0, 0, 0);  
    
        glTexCoord2f(0.0f, 1.0f); glVertex3f(1, 0, 1);
        glTexCoord2f(1.0f, 1.0f); glVertex3f(1, -1, 1);
        glTexCoord2f(1.0f, 0.0f); glVertex3f(1, -1, 0);
        glTexCoord2f(0.0f, 0.0f); glVertex3f(1, 0, 0);
    
        glTexCoord2f(0.0f, 1.0f); glVertex3f(0, 0, 1);
        glTexCoord2f(1.0f, 1.0f); glVertex3f(1, 0, 1);
        glTexCoord2f(1.0f, 0.0f); glVertex3f(1, 0, 0);
        glTexCoord2f(0.0f, 0.0f); glVertex3f(0, 0, 0);
        
        glTexCoord2f(0.0f, 1.0f); glVertex3f(0, -1, 1);
        glTexCoord2f(1.0f, 1.0f); glVertex3f(1, -1, 1);
        glTexCoord2f(1.0f, 0.0f); glVertex3f(1, -1, 0);
        glTexCoord2f(0.0f, 0.0f); glVertex3f(0, -1, 0);
   
        glTexCoord2f(0.0f, 1.0f); glVertex3f(0, 0, 0);
        glTexCoord2f(1.0f, 1.0f); glVertex3f(1, 0, 0);
        glTexCoord2f(1.0f, 0.0f); glVertex3f(1, -1, 0);
        glTexCoord2f(0.0f, 0.0f); glVertex3f(0, -1, 0);
    glEnd();
}

void game::drawSkyBox(GLuint texture1, GLuint texture2, GLuint texture3, GLuint texture4, GLuint texture5, GLuint texture6)
{
    float skyboxSize = 270.0f;
             
    glPushMatrix();
        // Render the front quad
        glBindTexture(GL_TEXTURE_2D, texture1); // takes the texture name generated by glGenTexture, so it can't be run before glGenTexture.	
        glBegin(GL_QUADS);
            glTexCoord2f(0, 0); glVertex3f(  skyboxSize, -skyboxSize, -skyboxSize ); // bl
            glTexCoord2f(1, 0); glVertex3f( -skyboxSize, -skyboxSize, -skyboxSize ); // br
            glTexCoord2f(1, 1); glVertex3f( -skyboxSize,  skyboxSize, -skyboxSize ); // ur
            glTexCoord2f(0, 1); glVertex3f(  skyboxSize,  skyboxSize, -skyboxSize ); // ul
        glEnd();
        //glDeleteTextures( 1, &skybox[0]);
     
        // Render the left quad
        glBindTexture(GL_TEXTURE_2D, texture2);	
        glBegin(GL_QUADS);
            glTexCoord2f(0, 0); glVertex3f(  skyboxSize, -skyboxSize,  skyboxSize );
            glTexCoord2f(1, 0); glVertex3f(  skyboxSize, -skyboxSize, -skyboxSize );
            glTexCoord2f(1, 1); glVertex3f(  skyboxSize,  skyboxSize, -skyboxSize );
            glTexCoord2f(0, 1); glVertex3f(  skyboxSize,  skyboxSize,  skyboxSize );
        glEnd();
     
        // Render the back quad
        glBindTexture(GL_TEXTURE_2D, texture3);  	
        glBegin(GL_QUADS);
            glTexCoord2f(0, 0); glVertex3f( -skyboxSize, -skyboxSize,  skyboxSize );
            glTexCoord2f(1, 0); glVertex3f(  skyboxSize, -skyboxSize,  skyboxSize );
            glTexCoord2f(1, 1); glVertex3f(  skyboxSize,  skyboxSize,  skyboxSize );
            glTexCoord2f(0, 1); glVertex3f( -skyboxSize,  skyboxSize,  skyboxSize );
        glEnd();
     
        // Render the right quad
        glBindTexture(GL_TEXTURE_2D, texture4);  	
        glBegin(GL_QUADS);
            glTexCoord2f(0, 0); glVertex3f( -skyboxSize, -skyboxSize, -skyboxSize );
            glTexCoord2f(1, 0); glVertex3f( -skyboxSize, -skyboxSize,  skyboxSize );
            glTexCoord2f(1, 1); glVertex3f( -skyboxSize,  skyboxSize,  skyboxSize );
            glTexCoord2f(0, 1); glVertex3f( -skyboxSize,  skyboxSize, -skyboxSize );
        glEnd();
     
        // Render the top quad
        glBindTexture(GL_TEXTURE_2D, texture5);  	
        glBegin(GL_QUADS);
            glTexCoord2f(0, 1); glVertex3f( -skyboxSize,  skyboxSize, -skyboxSize );
            glTexCoord2f(0, 0); glVertex3f( -skyboxSize,  skyboxSize,  skyboxSize );
            glTexCoord2f(1, 0); glVertex3f(  skyboxSize,  skyboxSize,  skyboxSize );
            glTexCoord2f(1, 1); glVertex3f(  skyboxSize,  skyboxSize, -skyboxSize );
        glEnd();
     
        // Render the bottom quad
        glBindTexture(GL_TEXTURE_2D, texture6);  	
        glBegin(GL_QUADS);
            glTexCoord2f(0, 0); glVertex3f( -skyboxSize, -skyboxSize, -skyboxSize );
            glTexCoord2f(0, 1); glVertex3f( -skyboxSize, -skyboxSize,  skyboxSize );
            glTexCoord2f(1, 1); glVertex3f(  skyboxSize, -skyboxSize,  skyboxSize );
            glTexCoord2f(1, 0); glVertex3f(  skyboxSize, -skyboxSize, -skyboxSize );
        glEnd();
     glPopMatrix();   
}
    
void floor(GLdouble red, GLdouble green, GLdouble blue, GLuint texture) // Draw floor tile
{
    glColor3f(red, green, blue); // Used to colour goal tile etc
    glDisable(GL_COLOR_MATERIAL); 
    glBindTexture(GL_TEXTURE_2D, texture);
    
    glBegin(GL_QUADS); // Quad
    glNormal3f(0.0f, 0.0f, 1.0f);
        glTexCoord2f(0.0f, 1.0f); glVertex3f(0,0,0);
        glTexCoord2f(1.0f, 1.0f); glVertex3f(1,0,0);
        glTexCoord2f(1.0f, 0.0f); glVertex3f(1,-1,0);
        glTexCoord2f(0.0f, 0.0f); glVertex3f(0,-1,0);
    glEnd();
}

game::game() // Construct a game
{
    level = 1; // Set first level
    
    for(int i = 0; i < 16; i++)
    {
        for(int j = 0; j < 20; j++)
        {
            finish[j][i] = FALSE; // Set goal tiles to FALSE i.e. no blocks on them
        }
    }
}

bool game::loadlevel()
{   
    char ltype; // Hold level number as char
    int type; // Hold level number as int
    stringstream num; // input stream to read levels file
    
    num << level; // Set first level number as number
    
    for(int i = 0; i < 16; i++)
    { 
        for(int j = 0; j < 20; j++)
        {
                finish[j][i] = FALSE; // CLear the environment before loading level
                env[j][i] = 0;
        }
    }
    
    string find = "level.level" + num.str(), loaded = "";
    
    ifstream levels;
    levels.clear();
    levels.open("Levels.lvl");
    
    while(loaded != find && !levels.eof())
    {
        levels >> loaded;
    }
    
    if (loaded != find)
    {
        return FALSE;
    }
    
    else
    {
        for (int i = 0; i < 16; i++)
        {
            for (int j = 0; j < 20; j++)
            {
                levels >> ltype;
                type = ltype - 48;
                
                if (type < 3 || type == 6) // Set blocks, walls, empty space and floor tiles
                {
                    env[j][i] = type;
                }
                
                if (type == 3) // Goal tile
                {
                    finish[j][i] = TRUE;
                }
                
                if (type == 4) // Player block
                {
                    playerxy[0] = j; // Player coordinates
                    playerxy[1] = i;
                    env[j][i] = 6; // Set floor tile
                }
                
                if (type == 5) // Block on goal tile
                {
                    finish[j][i] = TRUE;
                    env[j][i] = 2; // Set block
                }
                
                if (type == 7) // Player on goal tile
                {
                    finish[j][i] = TRUE;
                    playerxy[0] = j; // Player coordinates
                    playerxy[1] = i;
                }
            }
        }
        levels.close();
        return TRUE;
    }
}

void game::nextlvl() // Load next level
{
    if (level < levelov) // if level is less than number of last level
    {
        level++;
    }
}

void game::prevlvl() // Load previous level
{
    if (level > 1)
    {
        level--;
    }
}
    
void game::draw(GLuint* texture, GLfloat move_x, GLfloat move_y, GLfloat move_z)
{
     glPushMatrix();
         glTranslatef(move_x, move_y, move_z); // Translation of maze
     
         for(int j = 0; j < 16; j++)
         {
             for(int i = 0; i < 20; i++)
             {
                 switch(env[i][j]) 
                 {
                     case 1 :
                     { 
                         box(texture[0]); // Wall texture
                         break;
                     }
                             
                     case 2 :
                     { 
                          if (finish[i][j])
                          { 
                              box(texture[4]); // Black and white box texture
                          }
                                 
                          else 
                          {   
                              box(texture[1]); // Rainbow box texture
                          }    
                          break;
                     }
                             
                     case 6 :
                     { 
                          floor(1, 1, 1, texture[2]); // Floor tile texture
                          break;
                     }
                 }
            
                 if (finish[i][j]) // check for exits
                 {
                     floor(0.0, 0.0, 0.0, texture[5]); // boxes go here
                 }
            
                 if (i == playerxy[0] && j == playerxy[1])
                 {
                     box(texture[3]); // Player texture
                 }
                 glTranslatef(1, 0, 0); // Translate one unit per block
             }
             glTranslatef(-20, -1, 0); // Next row
         }
         glTranslatef(0, 16, 0); // Go back to origin
    glPopMatrix();  
}

void game::drawplayer(GLdouble x, GLdouble y, GLuint texture) // Draw player box
{
    glTranslatef(x, y, 0);
        box(texture);
    glTranslatef(-x, -y, 0);
}
    
bool game::finished() // Detect if level is completed
{
    int k = 0;
    
    for(int j = 0; j < 16; j++)
    {
        for(int i = 0; i < 20; i++)
        {
            if (finish[i][j]) // if goal tile
            { 
                if (env[i][j] != 2) // and no block on it
                {
                    k++; // then block not on goal position
                }
            }
        }
    }
    
    if (k == 0) // Blocks on goal postions
    { 
        return TRUE;
    }
    else // Blocks not on goal positions
    {
        return FALSE;
    }
}   
